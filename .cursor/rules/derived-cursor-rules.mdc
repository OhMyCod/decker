---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## TECH STACK

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

## CODING STANDARDS

## WORKFLOW & RELEASE RULES

Based on the project implementation plan for DECKER, a simplified Git Flow strategy is recommended:

### Main Branches

1. **`main`** (or `master`)
   - Contains production-ready code, always stable.
   - Automatically deployed to Vercel.
   - Protected against direct pushes.

2. **`develop`**
   - Main development branch.
   - Integrates all completed features.
   - Base for creating feature branches.

### Feature Branches

For each phase or major functionality, create dedicated branches:

**Example:**
```bash
feature/sidebar-navigation
feature/theme-system
feature/header-footer
```

**Phase 4 - Histoire familiale :**
```bash
feature/histoire-familiale
feature/timeline-interactive
```

**Phase 5 - Créations artistiques :**
```bash
creations-musique
creations-photos
creations-peintures
creations-videos
creations-textes
```

**Phase 6 - Archives :**
```bash
archives-photos
archives-ina
archives-documents
```

**Other features:**
```bash
feature/arbre-genealogique
feature/portraits-membres
feature/temoignages
telechargements
admin-panel
```

### Hotfix Branches

```bash
fix/name-of-the-bug
hotfix/urgent-production-fix
```

### Naming Conventions

- `feature/` : New features
- `fix/` : Bug fixes
- `hotfix/` : Urgent production fixes
- `refactor/` : Code refactoring
- `docs/` : Documentation
- `style/` : CSS/styling modifications

### Workflow

1. **Start a new feature:**
   ```bash
   git checkout develop
   git pull origin develop
   git checkout -b feature/your-feature
   ```

2. **Work on the feature** with regular commits.

3. **Merge into develop:**
   ```bash
   git checkout develop
   git merge feature/your-feature
   git push origin develop
   git push origin develop
   ```

4. **Deploy to production:**
   ```bash
   git checkout main
   git merge develop
   git push origin main
   ```

## DEBUGGING

When facing build errors related to linting, such as unescaped apostrophes or missing alt attributes in images, temporarily disable the specific ESLint rules causing the errors in `.eslintrc.json` to proceed with development. After resolving the core functionality, re-enable the rules and address the linting issues properly.

When passing data from Server Components to Client Components in Next.js 13+, ensure that you only pass plain JavaScript objects. Functions or class instances cannot be directly serialized and passed to Client Components. To solve this, pass only the necessary data (e.g., names or IDs) and then import the required components/functions directly within the Client Component.

When using the `ScrollArea` component from `shadcn/ui`, be aware that it does not accept the `orientation` prop directly. The `orientation` prop should be applied to the nested `ScrollBar` component instead.

When encountering a TypeScript error in `use-timeline-sync.ts` related to the type of `mostVisible`, ensure correct type narrowing. Specifically:

1.  Replace `!mostVisible` with `mostVisible === null` for more explicit null checking.
2.  Extract the `entry` property into a local variable after verifying that `mostVisible` is not null to improve type inference. Example:

```typescript
if (mostVisible) {
  const entry = mostVisible.entry;
  const sectionId = entry.target.getAttribute("data-timeline-section");
  // ...
}
```
3. If the above steps don't resolve the TypeScript error in `use-timeline-sync.ts`, define an explicit type `MostVisibleType` and use a type assertion `as MostVisibleType` to access the `entry` property after null check:

```typescript
type MostVisibleType = { entry: IntersectionObserverEntry; ratio: number }

if (mostVisible) {
    // TypeScript type narrowing issue workaround
    const mostVisibleEntry = (mostVisible as MostVisibleType).entry
    const sectionId = mostVisibleEntry.target.getAttribute("data-timeline-section")
    if (sectionId) {
        setActiveSectionId(sectionId)
    }
}
```

## REFERENCES

# Directives du Depot - Site Web Famille DECKER

## Vue d'ensemble du projet

DECKER est une application web généalogique et artistique dédiée à l'exploration des archives familiales. Le projet combine la préservation du patrimoine familial avec une présentation artistique moderne, utilisant une stack technique moderne : Next.js 15, TypeScript, Tailwind CSS, shadcn/ui, et Supabase.

## Structure du projet et organisation des modules

### Architecture principale
- `app/` : Pages et layouts Next.js App Router ; ne modifiez `layout.tsx` ou `globals.css` que pour des changements globaux
- `components/` : Composants React réutilisables avec dossier `ui/` pour les atomes shadcn/Radix
- `lib/` : Utilitaires, clients Supabase (`lib/supabase/*.ts`) et services métier (`lib/services/*.ts`)
- `hooks/`, `contexts/` et `types/` : Comportements réutilisables et contrats TypeScript
- `supabase/` : Migrations SQL, buckets et fonctions ; `public/`, `docs/` pour assets et références

### Fonctionnalités implémentées
- **Navigation** : Sidebar, Breadcrumb, NavigationMenu, Tabs
**Thème** : Système clair/sombre avec persistance et mode système
- **Timeline historique** : Composant animé synchronisé avec le scroll vertical sur les pages histoire
- **Composants UI** : Bibliothèque complète shadcn/ui (Button, Card, Dialog, Tooltip, etc.)

## Commandes de build, test et développement

- `npm install` : Synchronise les dépendances avant de coder
- `npm run dev` : Lance Next.js sur `http://localhost:3000` avec Fast Refresh
- `npm run build` : Valide le bundle de production ; `npm start` sert ce bundle
- `npm run lint` : Execute `next lint` (ESLint + Prettier) sur tout le repo ; corrigez les alerts avant push
- `vercel --prod` : Force un déploiement manuel, en suivant `DEPLOIEMENT.md`

## Style de code et conventions de nommage

### Design System
- `STYLE_GUIDE.md` définit les couleurs familiales, typographies et tokens d'accessibilité
- Palette DECKER : couleurs sémantiques (heritage, warmth, creativity, legacy, nature)
- Typographie : Geist Sans/Mono avec échelle personnalisée
- Espacements et breakpoints responsives personnalisés

### Conventions techniques
- TypeScript en mode strict (`tsconfig.json`)
- Composants PascalCase, atomes custom préfixés `Custom`
- Logique métier dans `lib/`, UI dans `components/`
- ESLint/Prettier automatiques ; classes Tailwind sémantiques préférées aux valeurs hex

## Directives de test

- Suite automatisée non implémentée ; vérifications via `npm run lint` et tests manuels
- Tests placés côte à côte (`lib/services/members.test.ts`) avec suffixe `*.test.ts(x)`
- Vérifications Supabase documentées dans `docs/` pour reproductibilité

## Directives pour commits et pull requests

### Messages de commit
- Descriptifs en français avec préfixes : `feat:`, `fix:`, `docs:`
- Branches : `feature/nom-fonctionnalite` ou `fix/nom-bug`

### Pull Requests
- Inspirées de `PR_PHASE_3_DESCRIPTION.md` : résumé, objectifs cochables, tests
- Liens vers issues ou `PLAN.md`, captures UI, blocage fusion si `npm run lint` échoue

## Conseils de sécurité et configuration

### Variables d'environnement
- Jamais de secrets commités ; copier `.env.local.example` vers `.env.local`
- Clés Supabase et sensibles dans l'espace secrets local uniquement
- Renouvellement via console Supabase (voir `SUPABASE_STATUS.md`)

### Déploiement et migrations
- Suivre `DEPLOIEMENT.md`, `BOLT_SUPABASE_SETUP.md` et `BOLT_APPLY_API_MIGRATION.md`
- Modifications migrations/buckets dans `supabase/` après vérifications

## Composants UI disponibles (shadcn/ui)

### Composants installés
**Navigation** : Sidebar, Breadcrumb, NavigationMenu, Tabs
**Formulaires** : Input, Select, Checkbox, Switch, Form, Label
**Feedback** : Alert, Toast, Dialog, Sheet, Tooltip, Popover, HoverCard
**Médias** : AspectRatio, Carousel, ScrollArea
**Layout** : Card, Separator, Skeleton, Collapsible, Accordion
**Actions** : Button, DropdownMenu, ContextMenu, Command

### Utilisation recommandée
- Tous les composants UI doivent utiliser shadcn/ui exclusivement
- Personnalisation via variants et classes Tailwind
- Accessibilité WCAG intégrée par défaut

## Fonctionnalités avancées implémentées

### Timeline historique animée
- Composant `HistoireTimeline` avec synchronisation scroll vertical
- Hook `useTimelineSync` utilisant Intersection Observer
- Animations : `timeline-progress`, `timeline-pulse` dans Tailwind
- Responsive : adaptation mobile avec tailles réduites
### Structure des pages histoire
- Layout partagé avec breadcrumb dynamique
- 5 périodes chronologiques : Origines, XIXᵉ, XXᵉ, Après-guerre, Actuelle
- Navigation synchronisée entre timeline et contenu